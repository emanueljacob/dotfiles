# Docker
function docker-shell() {
  docker exec -it "$@" bash
}

# Create a new directory and enter it
function mkd() {
  mkdir -p "$@" && cd "$@"
}

# All the dig info
function digga() {
  dig +nocmd "$1" any +multiline +noall +answer
}

function archive() {
  zip -r "$1".zip -i "$1"
}

function removehost() {
  ssh-keygen -R "$1"
}

alias mysqladm='mysql -u root'

# Scrape a single webpage with all assets
function scrapeurl() {
  wget --adjust-extension --convert-links --page-requisites --span-hosts --no-host-directories "$1"
}

function db {
  if [ "$1" = "refresh" ]; then
    mysql -uroot -e "drop database $2; create database $2"
  elif [ "$1" = "create" ]; then
    mysql -uroot -e "create database $2"
  elif [ "$1" = "drop" ]; then
    mysql -uroot -e "drop database $2"
  elif [ "$1" = "import" ]; then
    if [ "${2##*.}" = "gz" ]; then
        cat "$2" | gunzip | mysql -uroot "$3"
    else
        cat "$2" | mysql -uroot "$3"
    fi;
  elif [ "$1" = "list" ]; then
    mysql -uroot -e "show databases" | perl -p -e's/\|| *//g'
  fi
}

function opendb() {
  [ ! -f .env ] && {
    echo "No .env file found."
    exit 1
  }

  DB_CONNECTION=$(grep DB_CONNECTION .env | grep -v -e '^\s*#' | cut -d '=' -f 2-)
  DB_HOST=$(grep DB_HOST .env | grep -v -e '^\s*#' | cut -d '=' -f 2-)
  DB_PORT=$(grep DB_PORT .env | grep -v -e '^\s*#' | cut -d '=' -f 2-)
  DB_DATABASE=$(grep DB_DATABASE .env | grep -v -e '^\s*#' | cut -d '=' -f 2-)
  DB_USERNAME=$(grep DB_USERNAME .env | grep -v -e '^\s*#' | cut -d '=' -f 2-)
  DB_PASSWORD=$(grep DB_PASSWORD .env | grep -v -e '^\s*#' | cut -d '=' -f 2-)

  DB_URL="${DB_CONNECTION}://${DB_USERNAME}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_DATABASE}"

  echo "Opening ${DB_URL}"
  open $DB_URL
}

# Open a PR from the current branch
function openpr() {
  br=`git branch | grep "*"`
  repo=$1
  parentBranch=$2
  [ -z "$repo" ] || [ -z "$parentBranch" ] && echo "Please provide a repository and a parentbranch" && return 1
  echo "Creating pull request for Repository '${repo}' and parent branch '${parentBranch}'"
  repo=${repo#"https://github.com/"} # subtract prefix if passed
  open -a /Applications/Google\ Chrome.app  https://github.com/${repo/* /}/compare/${parentBranch/* /}...emanueljacob:${br/* /}\?expand\=1
}

function scheduler() {
  while :; do
    php artisan schedule:run
    echo "Sleeping 60 seconds..."
    sleep 60
  done
}

function silent() {
  "$@" >&/dev/null
}

function stopservices() {
  echo "stopping apache"
  sudo apachectl stop
  echo "stopping nginx"
  sudo nginx -s stop
}

function switchenvironment() {
  echo "tbd: stop b5 docker environment & start valet environment or vice versa"
}

function phpv() {
    brew unlink php@7.3 php@7.4 php@8.0 php@8.1 valet-php@7.3 valet-php@7.4 valet-php@8.0 valet-php@8.1
    brew link --force --overwrite $1
}

function phpv-valet() {
    valet stop
    phpv $1
    #brew services start $1
    #composer global update
	  #rm -f ~/.config/valet/valet.sock
    valet start
}

function apachestatus() {
  status="$(netstat -at | grep LISTEN | grep *.http)"
  count="$(echo "${status}" | grep -Ev "^$" | wc -l)"

  if [ ${count} -eq 0 ] ; then
      echo " Apache server is not running"
  fi

  echo "${status}" |
  while IFS= read -r line
  do
      echo " ${line}"
  done
}

# MAMP shortcuts: runs a script from MAMP/bin
function mamp() {
  SCRIPT_PATH="/Applications/MAMP/bin/"
  if [ -z "$1" ]; then
    echo -en "Please provide a script to run.\\n\\nAvailable scripts:"
    (
      cd $SCRIPT_PATH \
      && echo -e "\033[0;34m" \
      && ls -1 *.sh | sed 's/\.[^.]*$//' | sed -E 's/(.*)/  \1/' && echo -en "\033[0m"
    )
    return 1
  fi
  RUN_SCRIPT="$SCRIPT_PATH$1.sh"
  [[ ! -f "$RUN_SCRIPT" ]] && echo "Script does not exist: '$RUN_SCRIPT'" && return 1
  $RUN_SCRIPT ${@:2}
}

# download files/folders as tar.gz file using rsync
function down() {
  local host="$1"
  local source="${2-./}"
  source=$( echo "${source}" | sed 's:/\{2,\}$:/:') # reduce multiple trailing slashes to only one
  local target="${3-${source%/}}"
  target=$( echo "${target}" | sed 's:/*$:/:') # reduce multiple trailing slashes to only one; always append one slash
  local exclude=${4:-}

  if [ -z "$host" ]; then
      echo -e "\033[0;31mPlease provide a ssh host. \033[0m "
      return 1
  fi

  # if exclude files are provided:
  if [ -n "$exclude" ]; then
    exclude=$(echo "--exclude='${exclude}'" | sed "s/,/' --exclude='/g")
  fi

  echo -e "\033[0;34mDownloading files on host '${host}' from '${source}', to '${target}'\033[0m"

  # 1. rsync via remote host, and on-the-fly create tar compressed file (via rsync-path trick)
  #    this way we are able to only login ONCE and also have a progress status
  #    this will also don't archive symlinks but the files they point to
  rsync -avzhr --progress --rsync-path="tar $exclude -hzcf "${source}.tar.gz" "${source}" && rsync" -e "ssh -T -c aes128-ctr -o Compression=no -x" "${host}:${source}.tar.gz" "${target}" \

  # 2. cleanup: remove the created tar file from remote host
  echo -e "\033[0;34mCleanup files on host '${host}' ('${source}.tar.gz')\033[0m"
  ssh "${host}" -- "rm ${source}.tar.gz"
}

# pack folder as tar.gz
function pack () {
  local source="${1:-./}"
  source=$( echo "${source}" | sed 's:/\{2,\}$:/:') # reduce multiple trailing slashes to only one
  local target="${2:-${source%/}}"
  target=${target%.tar.gz} # remove .tar.gz extension in case it was already provided
  local exclude=${3:-}

  # if exclude files are provided:
  if [ -n "$exclude" ]; then
    exclude=$(echo "--exclude='${exclude}'" | sed "s/,/' --exclude='/g")
  fi

  echo "Packing '${source}' to '${target}.tar.gz'"
  eval "tar $exclude -zcf ${target}.tar.gz ${source}"
}

# cd followed by ls shorthand
function cl() {
  DIR="$*";
  # if no DIR given, go home
  if [ $# -lt 1 ]; then
    DIR=$HOME;
  fi;
  builtin cd "${DIR}" && \
  ls -la
}
